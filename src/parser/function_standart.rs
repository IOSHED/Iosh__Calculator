
use crate::error::Errors;

use super::parser::{
    Parser, 
    ParseResult
};


// # КОМБИНАТОР
// При выдачи положительного результата парсером1, выполняется работа парсера 2.
// Функция возвращает последний вывод парсера2 и массив из 2х значений из парсера1, парсера2.

/*
 * Функция `pair` объединяет два парсера в один парсер, 
 * который парсит два значения и возвращает их в виде кортежа. 
 * В данном примере функция `pair` объединяет парсеры `parse_number()` и `match_literal(",")`, 
 * чтобы парсить два значения: число и запятую. Результатом парсинга будет кортеж из двух значений, 
 * которые можно обработать дальше с помощью функции `map`. 
 */

/*
 * Пример использования функции `pair`:

    ```rust

    // Создаем парсер, который парсит два числа, разделенных запятой
    let parser = map(pair(parse_number(), match_literal(",")), |(num1, _)| num1);

    // Парсим строку "42,13" и ожидаем получить число 42
    assert_eq!(parser.parse("42,13"), Some(("13", 42)));
    ```

 * В данном примере мы создаем парсер `parser`, который парсит два значения: число, 
 * которое возвращается из парсера `number`, и литерал ",", 
 * который парсится с помощью функции `match_literal`. Затем мы используем функцию `map`, 
 * чтобы преобразовать результат парсинга в число, возвращая только первое значение. 
 * Далее мы парсим строку "42,13" с помощью этого парсера и ожидаем получить кортеж из оставшейся части строки ("13") и числа 42. 
 */

pub fn pair<'a, P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Parser<'a, (R1, R2)>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    move |input| {
        parser1.parse(input).and_then(|(next_input, result1)| {
            parser2.parse(next_input)
                .map(|(last_input, result2)| (last_input, (result1, result2)))
        })
    }
}



// # ФУНКТОР
// Преобразует выходные данные парсера, а именно вторую его часть - вектор, в 
// Определённый вводимый тип.

/*
 * Этот код определяет функцию `map`, которая принимает в качестве аргументов вектор и функцию,
 * и возвращает новый вектор, полученный применением этой функции к каждому элементу входного вектора. 
 * Это называется операцией "отображения" (mapping) в функциональном программировании. 
 * Функция `map` используется для преобразования данных из одного формата в другой, например, 
 * для применения какой-то операции ко всем элементам коллекции.
 */

/*
 * Пример использования функции `map`:

    ```
    // преобразуем символ в число
    let parser = digit().map(|char| char.to_digit(10).unwrap());

    let input = "123";

    let result = parser.parse(input);

    assert_eq!(result, Ok(("".as_bytes(), 1)));
    ```

*   В данном примере функция `digit()` парсит один символ-цифру из входной строки, 
*   а затем функция `map` преобразует этот символ в число и возвращает его. 
*   В результате парсинга строки "123" получится значение `Ok(("".as_bytes(), 1))`, 
*   где первый элемент кортежа - оставшаяся часть входной строки (в данном случае пустая строка), 
*  а второй элемент - число 1, полученное из символа '1'.
*/

pub fn map<'a, P, F, A, B>(parser: P, map_fn: F) -> impl Parser<'a, B>
where
    P: Parser<'a, A>,
    F: Fn(A) -> B,
{
    move |input|
        parser.parse(input)
            .map(|(next_input, result)| (next_input, map_fn(result)))
}



// # ПАРСЕР
// Функция возвращает все символы строки, которые предшествуют введёному символу.

/*
 * Этот код определяет функцию `map`, которая принимает в качестве аргументов вектор и функцию,
 * и возвращает новый вектор, полученный применением этой функции к каждому элементу входного вектора.
 * Это называется операцией "отображения" (mapping) в функциональном программировании.
 * Функция `map` используется для преобразования данных из одного формата в другой, например, 
 * для применения какой-то операции ко всем элементам коллекции.
 */

/*
 * Пример использования функции `match_literal`:

    ```rust

    // Создаем парсер, который парсит литерал "hello"
    let parser = map(match_literal("hello"), |_| "matched");

    // Парсим строку "hello world" и ожидаем получить строку "matched"
    assert_eq!(parser.parse("hello world"), Some((" world", "matched")));
    ```

 * В данном примере мы создаем парсер `parser`, 
 * который парсит литерал "hello" с помощью функции `match_literal`. 
 * Затем мы используем функцию `map`, чтобы преобразовать результат парсинга в строку "matched".
 * Далее мы парсим строку "hello world" с помощью этого парсера и 
 * ожидаем получить кортеж из оставшейся части строки (" world") и строки "matched".
 */

pub fn match_literal<'a>(expected: &'static str) -> impl Parser<'a, ()> {
    move |input: &'a str| match input.get(0..expected.len()) {
        Some(next) if next == expected => {
            Ok((&input[expected.len()..], ()))
        },
        _ => Err(Errors::InvalidSyntax(input)),
    }
}



// # ПАРСЕР
// Функция использует 2 парсер, если парсер1 не сработал.

/*
 * Данная функция принимает два парсера (parser1 и parser2) и возвращает новый парсер, 
 * который пытается сначала применить parser1 к входным данным. 
 * Если parser1 успешно распарсил входные данные, то возвращается результат парсинга parser1. 
 * Если же parser1 не удалось распарсить входные данные, 
 * то возвращается результат парсинга parser2.
 */

/*
 * Пример использования функции:

    ```
    // Новый парсер, который попытается сначала распарсить символ 'a',
    // а если не получится, то распарсит символ 'b'
    let parser = either(parse_char_a(), parse_char_b());

    assert_eq!(parser.parse("a"), Ok(('a', "")));  
    assert_eq!(parser.parse("b"), Ok(('b', "")));
    assert_eq!(parser.parse("c"), Err(()));
    ```
 */

pub fn either<'a, P1, P2, A>(parser1: P1, parser2: P2) -> impl Parser<'a, A> 
where
    P1: Parser<'a, A>,
    P2: Parser<'a, A>,
{
    move |input| match parser1.parse(input) {
        ok @ Ok(_) => ok,
        Err(_) => parser2.parse(input),
    }
}


// # ПАРСЕР
// Функция применяет какаю-либо другую функцию, если парсер сработал успешно.

/*
 * Функция `and_then` принимает на вход парсер `parser` типа `P`, 
 * функцию `f` типа `F`, которая принимает результат парсинга `parser` и 
 * возвращает новый парсер типа `NextP`. Функция `and_then` возвращает новый парсер, 
 * который применяет сначала парсер `parser`, 
 * затем применяет функцию `f` к результату парсинга `parser` и 
 * получает новый парсер типа `NextP`. 
 * Новый парсер продолжает парсинг уже с измененным входом. 
 * Если парсинг `parser` завершается неудачно, то и новый парсер завершается неудачно. 
 * Функция `and_then` реализована как замыкание, которое захватывает переменные `parser` и `f`. 
 */

/*
 * Например, можно использовать функцию `and_then` для парсинга целых чисел, 
 * после чего применить к ним функцию возведения в квадрат:
 * 
    ```
    fn parse_int(input: &str) -> ParseResult<i32> {
        // реализация парсера целых чисел
    }

    fn square(x: i32) -> ParseResult<i32> {
        Ok(x * x)
    }

    let parser = and_then(parse_int, square);
    assert_eq!(parser.parse("42"), Ok(1764)); // 42^2 = 1764
    ``` 
 */

pub fn and_then<'a, P, F, A, B, NextP>(parser: P, f: F) -> impl Parser<'a, B>
where
    P: Parser<'a, A>,
    NextP: Parser<'a, B>,
    F: Fn(A) -> NextP,
{
    move |input| match parser.parse(input) {
        Ok((next_input, result)) => f(result).parse(next_input),
        Err(err) => Err(err),
    }
}



// # ЛЕВЫЙ ФУНКТОР
// Функция последовательно применяет, переданные ей парсеры, после чего 
// Оставляет только левую часть из полученного результата.

/*
 * Данный код определяет фу_нкцию `left`, которая принимает два парсера `parser1` и `parser2`,
 * оба из которых должны быть реализациями трейта `Parser`
 * с типами возвращаемых значений `R1` и `R2` соответственно. 

 * Функция `left` использует комбинатор `pair`, 
 * который применяет оба парсера последовательно к входному потоку и 
 * возвращает кортеж из результатов их работы. Затем комбинатор `map` применяется к этому кортежу,
 * чтобы вернуть только левый элемент из пары (элемент, полученный из первого парсера). 
 */

/*
 * Пример использования функции `left`:

    ```
    // Создаем парсер, который сначала парсит число, а затем букву
    let parser = pair(parse_number, parse_letter);

    let parser_left = left(parser);

    assert_eq!(parser_left.parse("1a"), Some(("a", 1)));
    ``` 

 * В данном примере мы создаем парсер `parser`, который парсит сначала число, 
 * а затем букву. Затем мы используем функцию `left`, чтобы получить только число из пары. 
 * Далее мы парсим строку "1a" с помощью этого парсера и 
 * ожидаем получить кортеж из оставшейся части строки ("a") и числа 1.
 */

pub fn left<'a, P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Parser<'a, R1>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    map(pair(parser1, parser2), |(left, _right)| left)
}



// # ПРАВЫЙ ФУНКТОР
// Функция последовательно применяет, переданные ей парсеры, после чего 
// Оставляет только правую часть из полученного результата.

/*
 * Данный код определяет функцию `right`, которая принимает два парсера `parser1` и `parser2`,
 * оба из которых должны быть реализациями трейта `Parser`
 * с типами возвращаемых значений `R1` и `R2` соответственно. 

 * Функция `right` использует комбинатор `pair`, 
 * который применяет оба парсера последовательно к входному потоку и 
 * возвращает кортеж из результатов их работы. Затем комбинатор `map` применяется к этому кортежу,
 * чтобы вернуть только правый элемент из пары (элемент, полученный из первого парсера). 
 */

/*
 * Пример использования функции `right`:

    ```
    // Создаем парсер, который сначала парсит число, а затем букву
    let parser = pair(parse_number, parse_letter);

    let parser_right = right(parser);

    assert_eq!(parser_right.parse("1a"), Some((1, "a")));
    ``` 

 * В данном примере мы создаем парсер `parser`, который парсит сначала число, 
 * а затем букву. Затем мы используем функцию `right`, чтобы получить только букву из пары. 
 * Далее мы парсим строку "1a" с помощью этого парсера и 
 * ожидаем получить кортеж из оставшейся части строки числа 1 и ("a").
 */

pub fn right<'a, P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Parser<'a, R2>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    map(pair(parser1, parser2), |(_left, right)| right)
}



// # ПЕРЕБОРЩИК
// Функция выпарсивает постоянно повторяющиеся элементы, евсли есть хотя бы 1 такой элемент.

/*
 * Эта функция принимает парсер в качестве входных данных и возвращает новый парсер, 
 * который применяет входной парсер один или более раз и возвращает вектор спарсенных элементов. 
 * Функция использует замыкание, которое принимает входную строку и возвращает результат, 
 * содержащий ошибку с исходным вводом, если парсер не может распарсить что-либо, 
 * или кортеж оставшегося ввода и вектора спарсенных элементов. 
 * Затем функция инициализирует пустой вектор для хранения спарсенных элементов и 
 * пытается распарсить входную строку с помощью входного парсера. Если это успешно, 
 * то добавляет спарсенный элемент в вектор и обновляет вход на оставшуюся часть после парсинга. 
 * Если парсинг не удался, то функция возвращает ошибку с исходным вводом. 
 * Затем функция переходит в цикл, 
 * который пытается распарсить входную строку снова с помощью входного парсера. 
 * Если это успешно, то добавляет спарсенный элемент в вектор и 
 * обновляет вход на оставшуюся часть после парсинга. Если парсинг не удался, то 
 * функция выходит из цикла и возвращает кортеж оставшегося ввода и вектора спарсенных элементов. 
 * В целом, эта функция предоставляет удобный способ для парсинга одного или 
 * более повторяющихся элементов с использованием заданного парсера.
 */

pub fn one_or_more<'a, P, A>(parser: P) -> impl Parser<'a, Vec<A>>
where
    P: Parser<'a, A>,
{
    move |mut input| {
        let mut result = Vec::new();

        if let Ok((next_input, first_item)) = parser.parse(input) {
            input = next_input;
            result.push(first_item);
        } else {
            return Err(Errors::InvalidSyntax(input))
        }

        while let Ok((next_input, next_item)) = parser.parse(input) {
            input = next_input;
            result.push(next_item);
        }

        Ok((input, result))
    }
}



// # ПЕРЕБОРЩИК
// Функция выпарсивает постоянно повторяющиеся элементы, даже если их нет.

/*
 * Данная функция `zero_or_more` принимает на вход парсер `parser`, 
 * который разбирает элементы типа `A`. Функция возвращает парсер,
 * который разбирает ноль или более элементов типа `A` из входной строки.
 *  Внутри функции создается пустой вектор `result`, 
 * который будет заполнен разобранными элементами. Затем, 
 * пока парсер `parser` успешно разбирает элементы из входной строки, 
 * они добавляются в вектор `result`. 
 * В конце функция возвращает пару из оставшейся части входной строки и вектора разобранных элементов.
 */

/*
 * Пример использования функции zero_or_more может быть следующим:

    ```
    // Парсер для чисел, разделенных запятыми
    fn numbers_parser<'a>() -> impl Parser<'a, Vec<i32>> {
        zero_or_more(
            // Парсер для одного числа
            |input| {
                let (input, num_str) = input.take_while(|c| c.is_digit(10))?;
                let num = num_str.parse().unwrap();
                Ok((input, num))
            }
        )
    }

    fn main() {
        let input = "123,456,789";
        let result = numbers_parser().parse(input);
        assert_eq!(result, Ok(("", vec![123, 456, 789])));
    }
    ```

 *   В этом примере мы создаем парсер для чисел, разделенных запятыми. 
 *  Он использует функцию zero_or_more, чтобы разобрать любое количество чисел. 
 *  Внутри zero_or_more мы передаем парсер для одного числа, 
 *  который разбирает последовательность цифр и преобразует ее в число типа i32.
 */

pub fn zero_or_more<'a, P, A>(parser: P) -> impl Parser<'a, Vec<A>>
where
    P: Parser<'a, A>,
{
    move |mut input| {
        let mut result = Vec::new();

        while let Ok((next_input, next_item)) = parser.parse(input) {
            input = next_input;
            result.push(next_item);
        }

        Ok((input, result))
    }
}



// # ПАРСЕР
// Функция просто берёт 1 символ.

/*
 * Функция any_char может использоваться для разбора любого символа из входной строки:

    ```
    let input = "hello";
    let result = any_char().parse(input);
    assert_eq!(result, Ok(("ello", 'h')));
    ```

 *  В этом примере мы создаем парсер для первого символа во входной строке. 
 * Он использует функцию any_char, чтобы разобрать первый символ. 
 * Внутри any_char мы используем метод chars() для получения итератора по символам входной строки. 
 * Затем мы берем первый символ и возвращаем его вместе с остатком строки.
 */

pub fn any_char(input: &str) -> ParseResult<char> {
    match input.chars().next() {
        Some(next) => Ok((&input[next.len_utf8()..], next)),
        _ => Err(Errors::InvalidSyntax(input)),
    }
}



// # ПРЕДИКАТОР
// Функция запускает парсер и после сверяет его результат с predicate.

/*
 *  Эта функция принимает три аргумента: парсер `parser`, предикат `predicate` и тип `A`. 
 * Она возвращает новый парсер, который принимает входную последовательность и 
 * пытается применить `parser` к этой последовательности. 
 * Если `parser` успешно распознает входную последовательность, 
 * то результат проверяется с помощью `predicate`. 
 * Если результат удовлетворяет предикату, то парсер возвращает успешный результат, 
 * иначе он возвращает ошибку. 

 * Таким образом, эта функция позволяет создавать новые парсеры, 
 * которые могут применяться к определенным типам данных и 
 * проверять результаты с помощью предикатов.
 */

/*
* Пример использования функции `pred` для создания парсера, который распознает целые числа и проверяет, что они меньше 10:

```
fn less_than_10(input: &str) -> Result<(&str, i32), &str> {
    pred(integer(), |&n| n < 10).parse(input)
}
```

* Здесь `integer()` - это другой парсер, который распознает целые числа. 
* Функция `less_than_10` создает новый парсер, 
* который применяет `integer()` к входной последовательности и проверяет, 
* что результат меньше 10 с помощью предиката. Если результат удовлетворяет предикату, 
* то парсер возвращает успешный результат, иначе он возвращает ошибку.
*/

pub fn pred<'a, P, A, F>(parser: P, predicate: F) -> impl Parser<'a, A>
where
    P: Parser<'a, A>,
    F: Fn(&A) -> bool,
{
    move |input| {
        if let Ok((next_input, value)) = parser.parse(input) {
            if predicate(&value) {
                return Ok((next_input, value));
            }
        }
        Err(Errors::InvalidSyntax(input))
    }
}  



// # КОНКАТЕНАТОР
// Конкатенирует значение типа (Vec<(String, String)>, String) в одну строку

pub fn string_concatenation<S>(value: (Vec<(S, S)>, S)) -> String 
where
    S: ToString,
{
    let mut string = String::new();

    let (vec_i, str) = value;

    for iter in vec_i.iter().into_iter() {
        string.push_str(&iter.0.to_string());
        string.push_str(&iter.1.to_string());
    }

    string.push_str(&str.to_string());

    string
}
