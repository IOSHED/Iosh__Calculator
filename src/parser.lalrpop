use std::str::FromStr;
use lalrpop_util::ParseError;
use lalrpop_util::ErrorRecovery;
use i_calc::errors::CalcErrors;
use i_calc::ast::{Expr, Opcode, FuncName};


grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, CalcErrors>>);


extern {
    type Error = CalcErrors;
}


pub Expr: Box<Expr<'input>> = { 
    Expr ExprOp Factor => Box::new(Expr::Op(<>)),
    Factor,
};


ExprOp: Opcode = { 
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};


Factor: Box<Expr<'input>> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Factor FactorOp Func => Box::new(Expr::Op(<>)),
    <f: Factor> <t: Term> => Box::new(Expr::Op(f, Opcode::Mul, t)),
    Term,
    Func,
};


FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    ":" => Opcode::Div,
    "mod" => Opcode::Mod,
    "div" => Opcode::IntDiv,
};


Func: Box<Expr<'input>> = {
    <n: FuncName> "(" <e: Expr> ")" => Box::new(Expr::Func(n, e)),
}


FuncName: FuncName = {
    "cos" => FuncName::Cos,
    "sin" => FuncName::Sin,
    "tg" => FuncName::Tg,
    "ctg" => FuncName::Ctg,
}


pub Term: Box<Expr<'input>> = {
    Num => Box::new(Expr::Number(<>)),
    Variable => Box::new(Expr::Variable(<>)),
    "(" <Expr> ")",

    ! => { errors.push(<>); Box::new(Expr::Error(CalcErrors::SyntaxError)) },
};


pub InitVariable: Box<Expr<'input>> = {
    <n: Variable> "=" <e: Expr> => Box::new(Expr::InitVariable(n, e))
}


pub Variable: &'input str = {
    r"[A-Za-z]+" => <>
}


pub Num: f64 = {
    r"[+-]?(\d+[\.\,]?\d*)|([\.\,]\d+)" =>? f64::from_str(&<>.replace(",", ".").to_string())
        .map_err(|_| ParseError::User {
            error: CalcErrors::InputTooBig
    }),
};